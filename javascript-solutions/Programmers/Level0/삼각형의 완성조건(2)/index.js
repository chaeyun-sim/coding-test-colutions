function solution(sides) {
    sides.push('0')
    sides.sort((a, b) => a - b)
    
    const arr = [];
    for (let i = sides[2] - sides[1]; i < sides[2] + sides[1] - 1; i++) {
        arr.push(i)
    }
    return arr.length
}

// sides에 0이라는 가상의 수를 추가한 뒤, 작은 수부터 순서대로 정렬한다.
// 만약 마지막수(2번)이 가장 큰 수라면, 2번은 1번 + 0번 보다 작아야한다.
// 즉, 2 < 1 + 0 => 2 - 1 < 0, 0번은 2번 - 1번보다 큰 것이다.
// 만약 가상의 수(0번)이 가장 큰 수라면, 0번은 2번 + 1번 보다 작아야한다.
// 즉, 0 < 2 + 1 => 2 + 1 > 0, 0번은 2 + 1보다 작은 것이다.
// 따라서 두개의 부등식을 합치면 2 - 1 < 0 < 2 + 1, 2-1보다 크고 2+1보다 작은 수가 답이 될 수 있다.




// 이런 방법도 있다!
function solution(sides) {
    return Math.min(...sides)*2-1
}
// 프로그래머스 답변자 설명: 
// sides = [a,b] 이고(a>b라고 가정, 이는 sort해주면됩니다.) 새로 주어지는 변의 길이를 c라고 했을 때, a가 가장 긴변인 경우 즉 a > c인 경우 b + c > a > c 이므로 a > c > a-b 이기 때문에 c의 정수 갯수는 b-1개입니다. / c가 가장 긴변인 경우도 이런식으로 하면 되고 a=c 인경우 한가지 이므로 2b-1이 나옵니다.